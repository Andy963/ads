"""CLI helpers for configuring MCP clients."""

from __future__ import annotations

import json
import re
import shutil
import sys
from datetime import datetime
from enum import Enum
from pathlib import Path
from typing import Iterable, Optional, Tuple

import typer
from rich.console import Console

from ..workspace.detector import WorkspaceDetector


console = Console()


class SetupError(RuntimeError):
    """Raised when configuration cannot be applied."""


class Client(str, Enum):
    """Supported MCP clients."""

    CODEX = "codex"
    CLAUDE = "claude"


SERVER_NAME = "ads"
DESCRIPTION = "ADS - AI-Driven Specification"


def setup_client(
    client: Client = typer.Argument(..., help="目标 MCP 客户端 (codex/claude)"),
    workspace: Optional[Path] = typer.Option(
        None,
        "--workspace",
        "-w",
        help="工作空间路径，默认自动检测",
        dir_okay=True,
        file_okay=False,
    ),
    use_pdm: bool = typer.Option(
        False,
        "--use-pdm",
        help="使用 `pdm run python` 启动 MCP Server",
    ),
    force: bool = typer.Option(
        False,
        "--force",
        "-f",
        help="覆盖已存在的配置项",
    ),
) -> None:
    """Configure ADS MCP server for the specified client."""

    workspace_path = Path(workspace).expanduser().resolve() if workspace else WorkspaceDetector.detect()

    if not workspace_path.exists():
        raise typer.BadParameter(f"工作空间路径不存在: {workspace_path}")

    if not WorkspaceDetector.is_initialized(workspace_path):
        console.print(
            "[yellow]⚠️  未检测到 .ads/workspace.json，建议先在目标项目中运行 `ads init`[/yellow]"
        )

    command, args = _resolve_command(use_pdm)

    try:
        if client is Client.CODEX:
            config_path, backup = _configure_codex(workspace_path, command, args, force)
        elif client is Client.CLAUDE:
            config_path, backup = _configure_claude(workspace_path, command, args, force)
        else:  # pragma: no cover - Enum guards this path
            raise SetupError(f"暂不支持的客户端: {client}")
    except SetupError as exc:
        console.print(f"[red]✖ 配置失败：{exc}[/red]")
        raise typer.Exit(1) from exc

    _print_success(client, config_path, backup)


def _resolve_command(use_pdm: bool) -> Tuple[str, Iterable[str]]:
    if use_pdm:
        return "pdm", ("run", "python", "-m", "ads.mcp.server")
    return sys.executable, ("-m", "ads.mcp.server")


def _configure_codex(
    workspace: Path,
    command: str,
    args: Iterable[str],
    force: bool,
) -> Tuple[Path, Optional[Path]]:
    config_dir = Path.home() / ".codex"
    config_path = config_dir / "config.toml"
    config_dir.mkdir(parents=True, exist_ok=True)

    block = _build_codex_block(workspace, command, args)
    backup: Optional[Path] = None

    if config_path.exists():
        text = config_path.read_text(encoding="utf-8")
        pattern = re.compile(rf"\[mcpServers\.{SERVER_NAME}\][\s\S]*?(?=\n\[|\Z)")

        if f"[mcpServers.{SERVER_NAME}]" in text:
            if not force:
                raise SetupError("配置已存在，使用 --force 覆盖")
            backup = _create_backup(config_path)
            text = pattern.sub(block, text, count=1)
        else:
            if text and not text.endswith("\n"):
                text += "\n"
            text += "\n" + block
    else:
        text = f"# Generated by ADS setup on {datetime.now().isoformat()}\n\n{block}\n"

    if not text.endswith("\n"):
        text += "\n"

    config_path.write_text(text, encoding="utf-8")
    return config_path, backup


def _build_codex_block(workspace: Path, command: str, args: Iterable[str]) -> str:
    args_value = ", ".join(json.dumps(str(arg)) for arg in args)
    lines = [
        f"[mcpServers.{SERVER_NAME}]",
        f"command = {json.dumps(str(command))}",
        f"args = [{args_value}]",
        f"cwd = {json.dumps(str(workspace))}",
        f"description = {json.dumps(DESCRIPTION)}",
        'type = "stdio"',
    ]
    return "\n".join(lines)


def _configure_claude(
    workspace: Path,
    command: str,
    args: Iterable[str],
    force: bool,
) -> Tuple[Path, Optional[Path]]:
    config_dir = Path.home() / ".claude"
    primary_path = config_dir / "config.json"
    legacy_path = Path.home() / ".claude.json"

    if primary_path.exists():
        target_path = primary_path
    elif legacy_path.exists():
        target_path = legacy_path
    else:
        target_path = primary_path

    if target_path == primary_path:
        primary_path.parent.mkdir(parents=True, exist_ok=True)

    data: dict = {}
    if target_path.exists():
        data = json.loads(target_path.read_text(encoding="utf-8"))

    projects = data.setdefault("projects", {})
    workspace_key = str(workspace)
    workspace_section = projects.setdefault(workspace_key, {})
    servers = workspace_section.setdefault("mcpServers", {})

    backup: Optional[Path] = None
    if SERVER_NAME in servers and not force:
        raise SetupError("配置已存在，使用 --force 覆盖")

    if target_path.exists() and SERVER_NAME in servers:
        backup = _create_backup(target_path)

    servers[SERVER_NAME] = {
        "command": str(command),
        "args": [str(arg) for arg in args],
        "cwd": workspace_key,
        "description": DESCRIPTION,
    }

    workspace_section["mcpServers"] = servers
    projects[workspace_key] = workspace_section
    data["projects"] = projects

    target_path.write_text(
        json.dumps(data, indent=2, ensure_ascii=False) + "\n",
        encoding="utf-8",
    )

    return target_path, backup


def _create_backup(path: Path) -> Path:
    timestamp = datetime.now().strftime("%Y%m%d%H%M%S")
    backup_path = path.with_suffix(path.suffix + f".bak{timestamp}")
    shutil.copy2(path, backup_path)
    return backup_path


def _print_success(client: Client, config_path: Path, backup: Optional[Path]) -> None:
    message = f"[green]✓ 已完成 {client.value} 配置: [bold]{config_path}[/bold][/green]"
    console.print(message)

    if backup:
        console.print(f"[dim]备份文件: {backup}[/dim]")

    console.print(
        "[cyan]提示：重启对应的 MCP 客户端以加载最新配置。[/cyan]"
    )
