import type { Context } from 'grammy';
import type { SessionManager } from '../utils/sessionManager.js';
import type { AgentEvent } from '../../codex/events.js';
import { downloadTelegramImage, cleanupImages } from '../utils/imageHandler.js';

function chunkMessage(text: string, maxLen = 4000): string[] {
  if (text.length <= maxLen) {
    return [text];
  }

  const chunks: string[] = [];
  let current = '';
  const lines = text.split('\n');

  // è·Ÿè¸ªä»£ç å—çŠ¶æ€
  let inCodeBlock = false;

  for (const line of lines) {
    // æ£€æµ‹ä»£ç å—å¼€å§‹/ç»“æŸ
    if (line.trim().startsWith('```')) {
      inCodeBlock = !inCodeBlock;
    }

    // å¦‚æœåŠ ä¸Šè¿™è¡Œä¼šè¶…é•¿
    if (current.length + line.length + 1 > maxLen) {
      // å¦‚æœåœ¨ä»£ç å—ä¸­ï¼Œå…ˆé—­åˆä»£ç å—
      if (inCodeBlock && current) {
        current += '\n```';
        inCodeBlock = false;
      }
      
      if (current) {
        chunks.push(current.trim());
      }
      
      // å¦‚æœä¹‹å‰åœ¨ä»£ç å—ä¸­ï¼Œæ–°chunké‡æ–°å¼€å¯ä»£ç å—
      if (inCodeBlock) {
        current = '```\n' + line;
      } else {
        current = line;
      }
    } else {
      current += (current ? '\n' : '') + line;
    }
  }

  // å¤„ç†æœ€åä¸€ä¸ªchunk
  if (current) {
    // å¦‚æœè¿˜åœ¨ä»£ç å—ä¸­ï¼Œé—­åˆå®ƒ
    if (inCodeBlock) {
      current += '\n```';
    }
    chunks.push(current.trim());
  }

  return chunks;
}

function formatEvent(event: AgentEvent): string {
  const parts: string[] = [];
  
  if (event.phase === 'boot') {
    parts.push('ğŸš€ å¯åŠ¨ä¸­...');
  } else if (event.phase === 'analysis') {
    parts.push('ğŸ” åˆ†æä¸­...');
  } else if (event.phase === 'context') {
    parts.push('ğŸ“– åŠ è½½ä¸Šä¸‹æ–‡...');
  } else if (event.phase === 'editing') {
    parts.push('âœï¸ ç¼–è¾‘ä¸­...');
  } else if (event.phase === 'tool') {
    parts.push('ğŸ”§ è°ƒç”¨å·¥å…·...');
  } else if (event.phase === 'command') {
    parts.push('âš™ï¸ æ‰§è¡Œå‘½ä»¤...');
  } else if (event.phase === 'responding') {
    parts.push('ğŸ’¬ ç”Ÿæˆå“åº”...');
  } else if (event.phase === 'completed') {
    parts.push('âœ… å®Œæˆ');
  } else if (event.phase === 'error') {
    parts.push('âŒ é”™è¯¯');
  }

  if (event.title) {
    parts.push(event.title);
  }

  if (event.detail) {
    parts.push(`\n${event.detail}`);
  }

  return parts.join(' ');
}

// å…¨å±€ä¸­æ–­ç®¡ç†å™¨
const interruptManager = new InterruptManager();

export async function handleCodexMessage(
  ctx: Context,
  text: string,
  sessionManager: SessionManager,
  streamUpdateIntervalMs: number,
  imageFileIds?: string[]
) {
  const userId = ctx.from!.id;
  
  // æ£€æŸ¥æ˜¯å¦æœ‰æ´»è·ƒè¯·æ±‚
  if (interruptManager.hasActiveRequest(userId)) {
    await ctx.reply('âš ï¸ å·²æœ‰è¯·æ±‚æ­£åœ¨æ‰§è¡Œï¼Œè¯·ç­‰å¾…å®Œæˆæˆ–ä½¿ç”¨ /stop ä¸­æ–­');
    return;
  }
  
  const session = sessionManager.getOrCreate(userId);
  
  // åœ¨é¦–æ¬¡ä½¿ç”¨åä¿å­˜ thread IDï¼ˆç”¨äºæŒä¹…åŒ–ï¼‰
  const saveThreadIdIfNeeded = () => {
    const threadId = session.getThreadId();
    if (threadId) {
      sessionManager.saveThreadId(userId, threadId);
    }
  };

  // æ³¨å†Œè¯·æ±‚ï¼Œè·å–ä¸­æ–­æ§åˆ¶å™¨
  const abortController = interruptManager.registerRequest(userId);

  const sentMsg = await ctx.reply('ğŸ’­ å¼€å§‹å¤„ç†...', { parse_mode: 'Markdown' });
  let lastMessageContent = '';
  const eventMessages: string[] = [];
  let lastUpdate = Date.now();
  
  // ä¸‹è½½å›¾ç‰‡
  const imagePaths: string[] = [];
  if (imageFileIds && imageFileIds.length > 0) {
    try {
      for (let i = 0; i < imageFileIds.length; i++) {
        const path = await downloadTelegramImage(
          ctx.api,
          imageFileIds[i],
          `image-${i}.jpg`
        );
        imagePaths.push(path);
      }
      console.log(`[CodexAdapter] Downloaded ${imagePaths.length} images`);
    } catch (error) {
      cleanupImages(imagePaths);
      throw new Error(`å›¾ç‰‡ä¸‹è½½å¤±è´¥: ${(error as Error).message}`);
    }
  }

  // ç›‘å¬æµå¼äº‹ä»¶
  const unsubscribe = session.onEvent((event: AgentEvent) => {
    const formatted = formatEvent(event);
    const now = Date.now();

    if (formatted !== lastMessageContent && now - lastUpdate > streamUpdateIntervalMs) {
      lastMessageContent = formatted;
      lastUpdate = now;

      ctx.api
        .editMessageText(ctx.chat!.id, sentMsg.message_id, formatted, { parse_mode: 'Markdown' })
        .catch((err) => {
          // å¿½ç•¥ "message is not modified" é”™è¯¯
          if (!err.description?.includes('not modified')) {
            console.warn('[CodexAdapter] Failed to edit message:', err.message);
          }
        });
    }
  });

  try {
    // æ„å»ºè¾“å…¥ï¼ˆæ–‡æœ¬ + å›¾ç‰‡ï¼‰
    let input: string | Array<{ type: 'text'; text: string } | { type: 'local_image'; path: string }>;
    
    if (imagePaths.length > 0) {
      input = [
        { type: 'text', text },
        ...imagePaths.map(path => ({ type: 'local_image' as const, path }))
      ];
    } else {
      input = text;
    }

    const result = await session.send(input as any, {
      streaming: true,
    });

    unsubscribe();
    cleanupImages(imagePaths);
    
    // ä¿å­˜ thread ID ç”¨äºæŒä¹…åŒ–
    saveThreadIdIfNeeded();

      // å‘é€æœ€ç»ˆå“åº”
      let finalText = result.response;
      
      // æ·»åŠ  token ä½¿ç”¨ç»Ÿè®¡
      if (result.usage) {
        const stats = [
          `\n\nğŸ“Š Token ä½¿ç”¨:`,
          `â€¢ è¾“å…¥: ${result.usage.input_tokens}`,
        ];
        
        if (result.usage.cached_input_tokens > 0) {
          stats.push(`â€¢ ç¼“å­˜: ${result.usage.cached_input_tokens}`);
        }
        
        stats.push(`â€¢ è¾“å‡º: ${result.usage.output_tokens}`);
        stats.push(`â€¢ æ€»è®¡: ${result.usage.input_tokens + result.usage.output_tokens}`);
        
        finalText += stats.join(' ');
      }
      
      const chunks = chunkMessage(finalText);

    if (chunks.length === 1) {
      await ctx.api.editMessageText(ctx.chat!.id, sentMsg.message_id, chunks[0], { 
        parse_mode: 'Markdown' 
      }).catch(async (err) => {
        // Markdown è§£æå¤±è´¥ï¼Œå°è¯•ä¸ç”¨ Markdown
        console.warn('[CodexAdapter] Markdown parse failed, sending as plain text');
        await ctx.api.editMessageText(ctx.chat!.id, sentMsg.message_id, chunks[0]);
      });
    } else {
      await ctx.api.deleteMessage(ctx.chat!.id, sentMsg.message_id);
      
      // åˆ†ç‰‡å‘é€æ—¶ï¼Œè€ƒè™‘æ¶ˆæ¯å‘é€é—´éš”ï¼ˆé¿å…è§¦å‘ Telegram é™æµï¼‰
      for (let i = 0; i < chunks.length; i++) {
        if (i > 0) {
          // æ¯æ¡æ¶ˆæ¯é—´éš” 100msï¼Œé¿å…è¢« Telegram é™æµ
          await new Promise(resolve => setTimeout(resolve, 100));
        }
        
        await ctx.reply(chunks[i], { parse_mode: 'Markdown' }).catch(async () => {
          // Markdown å¤±è´¥ï¼Œå‘é€çº¯æ–‡æœ¬
          await ctx.reply(chunks[i]);
        });
      }
    }
  } catch (error) {
    unsubscribe();
    cleanupImages(imagePaths);
    const errorMsg = error instanceof Error ? error.message : String(error);
    await ctx.api.editMessageText(
      ctx.chat!.id,
      sentMsg.message_id,
      `âŒ é”™è¯¯: ${errorMsg}`,
      { parse_mode: 'Markdown' }
    ).catch(() => {
      // å¦‚æœç¼–è¾‘å¤±è´¥ï¼Œå‘é€æ–°æ¶ˆæ¯
      ctx.reply(`âŒ é”™è¯¯: ${errorMsg}`);
    });
  }
}
